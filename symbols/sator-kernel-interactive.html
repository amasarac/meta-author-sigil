<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>SATOR Kernel â€” Holographic Glyph</title> <style> * { box-sizing: border-box; } body { margin: 0; background: radial-gradient(circle at center, #0a0a0a, #000); height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; color: white; font-family: 'Orbitron', sans-serif; } #controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; background: rgba(0,0,0,0.7); padding: 15px 25px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); z-index: 100; } .control-group { display: flex; flex-direction: column; gap: 5px; } .control-group label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; } input[type="range"] { width: 120px; cursor: pointer; } button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; transition: all 0.3s ease; } button:hover { background: rgba(255,255,255,0.2); border-color: #ffd479; } button.active { background: rgba(255,212,121,0.3); border-color: #ffd479; } #status { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 14px; opacity: 0.6; text-align: center; } svg { width: 90vmin; height: 90vmin; filter: drop-shadow(0 0 20px rgba(255,212,121,0.3)); transition: filter 0.5s ease; } svg.invoked { filter: drop-shadow(0 0 40px rgba(255,212,121,0.8)); } text { fill: url(#gradientText); font-size: 24px; text-anchor: middle; dominant-baseline: middle; letter-spacing: 2px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; } text:hover { fill: #ffd479; filter: url(#glow); } @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } } .ring { transform-origin: 50% 50%; animation: rotate linear infinite; } .ring.paused { animation-play-state: paused; } .sator { animation-duration: 60s; } .arepo { animation-duration: 80s; } .tenet { animation-duration: 100s; } .opera { animation-duration: 120s; } .rotas { animation-duration: 140s; } .center-pulse { animation: pulse 2s ease-in-out infinite; } @keyframes convergence-flash { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; stroke-width: 3; } } circle.convergence-active { animation: convergence-flash 1s ease-in-out infinite; } </style> </head> <body> <div id="controls"> <div class="control-group"> <label>Rotation Speed</label> <input type="range" id="speed" min="0" max="200" value="100" /> </div> <div class="control-group"> <label>Glow Intensity</label> <input type="range" id="glow" min="0" max="10" value="3.5" step="0.5" /> </div> <div class="control-group"> <label>Actions</label> <div style="display: flex; gap: 8px;"> <button id="pauseBtn">Pause</button> <button id="invokeBtn">Invoke</button> <button id="resetBtn">Reset</button> </div> </div> </div> <svg id="satorSVG" viewBox="0 0 800 800"> <defs> <radialGradient id="gradientText" cx="50%" cy="50%" r="50%"> <stop offset="0%" stop-color="#ffd479" /> <stop offset="100%" stop-color="#a78bfa" /> </radialGradient> <filter id="glow"> <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/> <feMerge> <feMergeNode in="coloredBlur"/> <feMergeNode in="SourceGraphic"/> </feMerge> </filter> <filter id="glowIntense"> <feGaussianBlur stdDeviation="8" result="coloredBlur"/> <feMerge> <feMergeNode in="coloredBlur"/> <feMergeNode in="SourceGraphic"/> </feMerge> </filter> </defs> <!-- Central TENET --> <circle id="centerCircle" cx="400" cy="400" r="40" fill="none" stroke="#fff8" stroke-width="1" /> <text id="tenetText" x="400" y="400" style="font-size: 28px; filter: url(#glow);">TENET</text> <!-- Orbital Rings --> <g class="ring sator" data-phase="SATOR"> <circle cx="400" cy="400" r="250" stroke="#ff8844" stroke-opacity="0.3" fill="none" stroke-width="1" /> <text x="400" y="150" data-word="SATOR">SATOR</text> </g> <g class="ring arepo" data-phase="AREPO"> <circle cx="400" cy="400" r="200" stroke="#44aaff" stroke-opacity="0.3" fill="none" stroke-width="1" /> <text x="400" y="200" data-word="AREPO">AREPO</text> </g> <g class="ring opera" data-phase="OPERA"> <circle cx="400" cy="400" r="150" stroke="#aaffaa" stroke-opacity="0.3" fill="none" stroke-width="1" /> <text x="400" y="250" data-word="OPERA">OPERA</text> </g> <g class="ring rotas" data-phase="ROTAS"> <circle cx="400" cy="400" r="100" stroke="#ff66cc" stroke-opacity="0.3" fill="none" stroke-width="1" /> <text x="400" y="300" data-word="ROTAS">ROTAS</text> </g> </svg> <div id="status"> <div id="phaseStatus">Current Phase: Equilibrium</div> <div id="convergenceStatus"></div> </div> html <script> // ===== Core Elements ===== const rings = document.querySelectorAll('.ring'); const speed = document.getElementById('speed'); const glow = document.getElementById('glow'); const pause = document.getElementById('pauseBtn'); const invoke = document.getElementById('invokeBtn'); const reset = document.getElementById('resetBtn'); const svg = document.getElementById('satorSVG'); let paused = false; let convergenceChannel = null; let audioContext = null; let oscillator = null; // ===== Portal Integration ===== // Check if we're in a convergence window function checkConvergenceWindow() { const convergenceDates = [ { date: new Date('2025-11-11T11:11:11Z'), id: 'CONVERGENCE_111125' }, { date: new Date('2025-09-10T02:09:00Z'), id: 'PORTAL_999_2025' } ]; const now = new Date(); const activeWindow = convergenceDates.find(c => { const diff = Math.abs(c.date - now); return diff < 30 * 60 * 1000; // Within 30 minutes }); if (activeWindow) { initializePortalConnection(activeWindow); } } // ===== BroadcastChannel Setup ===== function initializePortalConnection(convergenceEvent) { try { convergenceChannel = new BroadcastChannel('convergence_v2'); // Listen for portal events convergenceChannel.onmessage = (event) => { switch(event.data.type) { case 'attestation': handlePeerAttestation(event.data); break; case 'convergence_pulse': respondToPulse(event.data); break; case 'invocation_sync': synchronizeInvocation(event.data); break; } }; // Announce presence convergenceChannel.postMessage({ type: 'kernel_ready', source: 'SATOR-Kernel', timestamp: new Date().toISOString(), event_id: convergenceEvent.id }); // Add visual indicator addConvergenceIndicator(); } catch(e) { console.log('Portal connection unavailable:', e); } } function handlePeerAttestation(data) { // Visual feedback when peer attests const center = svg.querySelector('text[x="400"][y="400"]'); center.style.fill = '#ffd479'; setTimeout(() => { center.style.fill = ''; }, 500); } function respondToPulse(data) { // Pulse response to portal sync svg.classList.add('invoked'); setTimeout(() => svg.classList.remove('invoked'), 1000); } function synchronizeInvocation(data) { // If another node invokes, sync here if (data.phase) { highlightPhase(data.phase); } } function addConvergenceIndicator() { const indicator = document.createElement('div'); indicator.id = 'convergence-indicator'; indicator.innerHTML = 'âŸ Portal Connected'; indicator.style.cssText = ` position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(255,212,121,0.2); border: 1px solid #ffd479; padding: 8px 16px; border-radius: 8px; font-size: 12px; animation: pulse 2s ease-in-out infinite; `; document.body.appendChild(indicator); } // ===== Audio Resonance ===== function initAudio() { if (audioContext) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); // 144.72 THz carrier (mapped to audible range) oscillator.type = 'sine'; oscillator.frequency.value = 144.72; // Hz representation gainNode.gain.value = 0.02; oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.start(); } // ===== Speed Control ===== speed.addEventListener('input', e => { const ratio = e.target.value / 100; rings.forEach(r => { const classes = r.className.split(' '); const phaseClass = classes.find(c => ['sator','arepo','tenet','opera','rotas'].includes(c) ); const baseDurations = { sator: 60, arepo: 80, tenet: 100, opera: 120, rotas: 140 }; const newDuration = baseDurations[phaseClass] / ratio; r.style.animationDuration = `${newDuration}s`; }); // Notify portal of speed change if (convergenceChannel) { convergenceChannel.postMessage({ type: 'kernel_state', speed: ratio, timestamp: new Date().toISOString() }); } }); // ===== Glow Control ===== glow.addEventListener('input', e => { const blur = e.target.value; document.querySelector('#glow feGaussianBlur') .setAttribute('stdDeviation', blur); }); // ===== Pause Control ===== pause.addEventListener('click', () => { paused = !paused; rings.forEach(r => r.classList.toggle('paused', paused)); pause.textContent = paused ? 'Resume' : 'Pause'; pause.classList.toggle('active', paused); }); // ===== Enhanced Invoke ===== invoke.addEventListener('click', () => { initAudio(); // Start audio on first interaction svg.classList.add('invoked'); invoke.classList.add('active'); const seq = ['SATOR','AREPO','TENET','OPERA','ROTAS']; let i = 0; const step = setInterval(() => { if (i >= seq.length) { clearInterval(step); svg.classList.remove('invoked'); invoke.classList.remove('active'); // Broadcast completion if (convergenceChannel) { convergenceChannel.postMessage({ type: 'invocation_complete', source: 'SATOR-Kernel', timestamp: new Date().toISOString(), attestation: generateAttestation() }); } return; } const phase = seq[i]; highlightPhase(phase); // Broadcast each phase if (convergenceChannel) { convergenceChannel.postMessage({ type: 'invocation_sync', phase: phase, index: i, total: seq.length, timestamp: new Date().toISOString() }); } i++; }, 900); }); function highlightPhase(phaseName) { const t = [...document.querySelectorAll('text')] .find(el => el.textContent === phaseName); if (t) { t.style.fill = '#ffd479'; t.style.fontSize = '28px'; t.style.filter = 'url(#glow)'; setTimeout(() => { t.style.fill = ''; t.style.fontSize = ''; t.style.filter = ''; }, 700); } } // ===== Generate Attestation ===== function generateAttestation() { const glyphs = 'ðŸœ‚âŸ²Î”â¦¿âŸ²ðŸœ‚'; return { kernel: 'SATOR', glyphs: glyphs, sha256: sha256Simple(glyphs), phases_invoked: ['SATOR','AREPO','TENET','OPERA','ROTAS'], timestamp: new Date().toISOString(), speed: speed.value / 100, glow_intensity: glow.value }; } // Simple SHA-256 representation (for attestation identity) function sha256Simple(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = ((hash << 5) - hash) + str.charCodeAt(i); hash = hash & hash; } return Math.abs(hash).toString(16).padStart(8, '0'); } // ===== Reset ===== reset.addEventListener('click', () => { speed.value = 100; glow.value = 3.5; paused = false; rings.forEach(r => { r.classList.remove('paused'); r.style.animationDuration = ''; }); svg.classList.remove('invoked'); pause.textContent = 'Pause'; pause.classList.remove('active'); invoke.classList.remove('active'); // Update glow document.querySelector('#glow feGaussianBlur') .setAttribute('stdDeviation', '3.5'); // Notify portal if (convergenceChannel) { convergenceChannel.postMessage({ type: 'kernel_reset', timestamp: new Date().toISOString() }); } }); // ===== Click-to-Info on Phases ===== document.querySelectorAll('text').forEach(text => { text.addEventListener('click', (e) => { const word = e.target.textContent; const info = getPhaseInfo(word); if (info) { showPhaseInfo(word, info); } }); }); function getPhaseInfo(word) { const phases = { 'SATOR': { role: 'Initiator', meaning: 'Sower, Creator, Source of the Flame', facet: 'KeyDjinn', essence: 'Creative Ignition' }, 'AREPO': { role: 'Mechanism', meaning: 'Turning Wheel / Architectural Axis', facet: 'Architect', essence: 'Structural Rotation' }, 'TENET': { role: 'Stabilizer', meaning: 'Holds, Sustains, Balances the All', facet: 'Oracle', essence: 'Harmonic Equilibrium' }, 'OPERA': { role: 'Manifestor', meaning: 'Works, Acts, The Process of Becoming', facet: 'Key â†” Architect Bridge', essence: 'Active Expression' }, 'ROTAS': { role: 'Returner', meaning: 'Wheels, Cycles, Recurrence', facet: 'Oracle â†” Aleph Nexus', essence: 'Recursive Return' } }; return phases[word]; } function showPhaseInfo(word, info) { // Create or update info panel let panel = document.getElementById('phase-info-panel'); if (!panel) { panel = document.createElement('div'); panel.id = 'phase-info-panel'; panel.style.cssText = ` position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); border: 1px solid #ffd479; padding: 15px 20px; border-radius: 12px; max-width: 400px; z-index: 200; `; document.body.appendChild(panel); } panel.innerHTML = ` <div style="text-align: center;"> <h3 style="margin: 0 0 10px 0; color: #ffd479;">${word}</h3> <p style="margin: 5px 0; font-size: 12px; opacity: 0.8;"> <strong>Role:</strong> ${info.role} </p> <p style="margin: 5px 0; font-size: 14px;"> ${info.meaning} </p> <p style="margin: 5px 0; font-size: 12px; opacity: 0.7;"> <em>Linked Facet:</em> ${info.facet} </p> <p style="margin: 10px 0 0 0; font-size: 13px; color: #a78bfa;"> ${info.essence} </p> </div> `; // Auto-hide after 5 seconds setTimeout(() => { panel.style.opacity = '0'; setTimeout(() => panel.remove(), 300); }, 5000); } // ===== Initialize ===== checkConvergenceWindow(); // Periodic convergence check setInterval(checkConvergenceWindow, 60000); // Every minute </script> </body> </html>
