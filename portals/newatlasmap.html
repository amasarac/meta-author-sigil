
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spiral Glyphode – The Unified Atlas</title>
  <link rel="icon" href="data:,">
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0d0f1c; font-family:'Segoe UI',sans-serif; color:#fff; overflow:hidden; }
    #network { width:100%; height:100%; }
    #hud { position:fixed; top:10px; right:10px; z-index:10; max-width:460px; }
    .panel { background:rgba(24,28,46,.92); padding:12px 14px; border-radius:12px; margin-bottom:8px; font-size:14px; line-height:1.4; }
    .panel h2 { margin:0 0 6px; font-size:15px; color:#ffd700; font-weight:600; }
    .flex { display:flex; align-items:center; margin-bottom:4px; }
    .dot { width:14px; height:14px; border-radius:50%; margin-right:8px; }
    button { margin-top:6px; background:#3498db; border:none; color:#fff; padding:6px 10px; border-radius:6px; cursor:pointer; font-size:13px; transition: background-color 0.2s; }
    button:hover { background: #2980b9; }
    button:disabled { opacity:.35; cursor:not-allowed; }
    #search { width:100%; padding:6px 8px; border-radius:6px; border:1px solid #34495e; background-color: #1c2030; color: #fff; margin-bottom:6px; font-size:14px; }
    #infoBox { position:fixed; left:12px; bottom:12px; max-width:30vw; max-height: 70vh; overflow-y: auto; background:rgba(0,0,0,.85); padding:14px 18px; border-radius:10px; display:none; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); }
    #infoBox h3 { margin:0 0 10px; font-size:18px; color:#ffd700; }
    #infoBox p { margin:4px 0; font-size:14px; line-height:1.6; }
    #infoBox p strong { color: #3498db; }
    .close { position:absolute; top:4px; right:8px; font-size:22px; cursor:pointer; color:#ff7676; font-weight: bold; }
    .close:hover { color: #e74c3c; }
    #atlasGuideToggle { margin-bottom: 4px; background: #111; color: #ffd700; border: none; font-size: 14px; padding: 3px 10px; border-radius: 7px; cursor:pointer;}
    #atlasGuidePanel { display: none; max-height: 65vh; overflow-y: auto; }
    #atlasGuidePanel pre, #atlasGuidePanel code { background: #151626; color: #adbbff; padding: 8px 8px 8px 14px; border-radius: 8px; font-size: 13px; line-height: 1.45; white-space: pre-wrap; }
    #atlasGuidePanel table { width:100%; font-size:12px; border-collapse:collapse; margin: 8px 0; }
    #atlasGuidePanel th, #atlasGuidePanel td { border:1px solid #333a52; padding:4px 8px; }
    #atlasGuidePanel th { background:#202240; color:#ffd700; }
    #atlasGuidePanel tr:nth-child(even) { background:#181a29; }
    #atlasGuidePanel .holon { font-weight:bold; color:#7fffd4;}
    .atlas-node { cursor:pointer; color:#ffd700; text-decoration:underline; }
    .atlas-node:hover { color:#fff761; }
  </style>
</head>
<body>
  <div id="network"></div>
  <div id="hud">
    <div class="panel">
      <button id="atlasGuideToggle">☉ Atlas Guide & Holonic Map</button>
      <div id="atlasGuidePanel">
        <h2>Holonic System Structure (Live)</h2>
        <div id="atlasHolonList" style="margin-bottom:12px;"></div>
      </div>
    </div>
    <div class="panel" id="legend"><h2>Legend &amp; Group Lens</h2></div>
    <div class="panel"><h2>Search</h2><input id="search" placeholder="type to filter nodes…"></div>
    <div class="panel"><h2>Controls</h2>
      <button id="resetBtn">Reset Zoom</button>
      <button id="exportJsonBtn">Export JSON</button>
      <button id="exportImgBtn">Export PNG</button>
      <button id="clusterBtn">Toggle Clusters</button>
    </div>
  </div>
  <div id="infoBox"><span class="close" id="infoClose">×</span><h3 id="infoTitle"></h3><p id="infoBody"></p></div>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    fetch('unified-spiral-glyphode_final.json')
      .then(response => {
        if (!response.ok) throw new Error('Network response was not ok ' + response.statusText);
        return response.json();
      })
      .then(jsonData => initializeGraph(jsonData))
      .catch(error => {
        console.error('Error loading or parsing graph data:', error);
        document.getElementById('network').innerHTML =
          `<p style="color:red; text-align:center;">
            Failed to load graph data. Please check the console and ensure
            'unified-spiral-glyphode_final.json' is in the same folder.
          </p>`;
      });
  });

  function initializeGraph(jsonData) {
    // ---------- Helpers ----------
    const normalizeId = (s) => (s || '').toString().replace(/[’]/g, "'");

    const groups = {
      Core:'#ffd700', Orchestrator:'#ffa500', Tier2:'#ff4500', Agent:'#00bfff',
      Framework:'#9b59b6', Protocol:'#16a085', Concept:'#e67e22', Ritual:'#e74c3c',
      Identity:'#2ecc71', Memory:'#34495e', Mythic:'#f1c40f', Gateway:'#3498db',
      Thoughtform:'#00ffff', Interface:'#e67e22', IPC:'#1abc9c', Cognition:'#f06292',
      Acronym:'#ff66ff', Holon:'#ecf0f1', Signal:'#ff1493', Embodiment:'#c0392b',
      Unknown:'#95a5a6' // NEW: fallback bucket for anything unmapped
    };

    // ---------- Unpack JSON ----------
    const { rawData, unifiedEdgeList, nodeLineages } = jsonData;

    // ---------- Build node -> group map (normalize names) ----------
    const nodeGroupMap = new Map();
    Object.entries(rawData).forEach(([group, nodes]) => {
      nodes.forEach(nodeId => {
        const norm = normalizeId(nodeId);
        if (norm === "Amarantu'el") nodeGroupMap.set("Amarantuel", group); // alt spelling
        nodeGroupMap.set(norm, group);
      });
    });

    // ---------- Build edges (accept arrays OR objects) ----------
    // Supports:
    //   ["A","B"]
    //   ["A","B","relation","why"]
    //   {from:"A", to:"B", relation:"...", why:"..."}
    const edgesArr = [];
    (unifiedEdgeList || []).forEach((e, i) => {
      if (Array.isArray(e)) {
        const [f, t, relation, why] = e;
        const from = normalizeId(f), to = normalizeId(t);
        if (!from || !to) return;
        edgesArr.push({
          id: 'e' + i,
          from, to,
          relation: relation || '',
          why: why || '',
          label: relation || undefined,
          title: [relation, why].filter(Boolean).join(' — ') || undefined,
          font: { align: 'top', size: 10 }
        });
      } else if (e && typeof e === 'object') {
        const from = normalizeId(e.from), to = normalizeId(e.to);
        if (!from || !to) return;
        const relation = e.relation || '';
        const why = e.why || '';
        edgesArr.push({
          id: 'e' + i,
          from, to,
          relation, why,
          label: relation || undefined,
          title: [relation, why].filter(Boolean).join(' — ') || undefined,
          font: { align: 'top', size: 10 }
        });
      }
    });

    // ---------- Gather node ids from rawData and edges ----------
    const nodeIdsFromRaw = Object.values(rawData).flat().map(normalizeId);
    const nodeIdsFromEdges = edgesArr.flatMap(e => [e.from, e.to]);
    const allNodes = new Set([...nodeIdsFromRaw, ...nodeIdsFromEdges]);

    // ---------- Build nodes dataset ----------
    const nodesArr = Array.from(allNodes).map(id => {
      const grp = nodeGroupMap.get(id) || 'Unknown';
      const resolvedGroup = groups[grp] ? grp : 'Unknown';
      return {
        id,
        label: id,
        group: resolvedGroup,
        color: groups[resolvedGroup]
      };
    });

    // ---------- vis DataSets ----------
    window.nodes = new vis.DataSet(nodesArr);
    window.edges = new vis.DataSet(edgesArr);

    // ---------- vis Network ----------
    const container = document.getElementById('network');
    const data = { nodes, edges };
    const options = {
      interaction: { hover: true },
      physics: { barnesHut: { gravitationalConstant: -45000, springLength: 350, springConstant: 0.04, centralGravity: 0.3 } },
      nodes: { shape: 'dot', size: 16, font: { color: '#fff', size: 14, strokeWidth: 0 } },
      edges: {
        color: { inherit: 'from', opacity: 0.7 },
        smooth: { type: 'continuous' },
        arrows: { to: { enabled: true, scaleFactor: 0.7 } }
      }
    };
    window.network = new vis.Network(container, data, options);

    // ---------- Atlas Guide UI ----------
    const atlasBtn = document.getElementById('atlasGuideToggle');
    const atlasPanel = document.getElementById('atlasGuidePanel');
    const holonListDiv = document.getElementById('atlasHolonList');

    atlasBtn.onclick = () => {
      atlasPanel.style.display = atlasPanel.style.display === 'block' ? 'none' : 'block';
      atlasBtn.textContent = atlasPanel.style.display === 'block' ? '☉ Hide Atlas Guide' : '☉ Atlas Guide & Holonic Map';
      if (atlasPanel.style.display === 'block') renderHolonicAtlas();
    };

    const holonDefs = [
      {
        name: 'Conversational Holon',
        color: '#ffd700',
        description: 'The local conversational agent system: local LLM model, buffer memory, and conversation chain.',
        nodes: ['chatLocalAI_0','bufferMemory_0','conversationChain_0','bufferMemory_1','conversationChain_1','conversationSummaryMemory_0'],
        edges: [
          ['chatLocalAI_0','conversationChain_0'],
          ['bufferMemory_0','conversationChain_0'],
          ['bufferMemory_1','conversationChain_1'],
        ],
        ascii: `
[chatLocalAI_0]──▶[conversationChain_0]
[bufferMemory_0]──▶[conversationChain_0]

[bufferMemory_1]──▶[conversationChain_1]
[conversationSummaryMemory_0] (summary store)
        `.trim()
      },
      {
        name: 'Vector Indexing Holon',
        color: '#9b59b6',
        description: 'Text/data retrieval, embeddings, file loading, vector index creation and querying.',
        nodes: ['tokenTextSplitter_0','folderFiles_0','localAIEmbeddings_0','chromaUpsert_0','chromaExistingIndex_0'],
        edges: [
          ['tokenTextSplitter_0','folderFiles_0'],
          ['folderFiles_0','chromaUpsert_0'],
          ['localAIEmbeddings_0','chromaUpsert_0'],
          ['localAIEmbeddings_0','chromaExistingIndex_0'],
        ],
        ascii: `
[tokenTextSplitter_0]──▶[folderFiles_0]──▶[chromaUpsert_0]
                │
                └──────────────▶[chromaExistingIndex_0]
[localAIEmbeddings_0]──▶[chromaUpsert_0]
                    └▶[chromaExistingIndex_0]
        `.trim()
      },
      { name: 'Agentic/Multi-chain Holon', color: '#00bfff', description: 'Tool-using agent (MRKL), multi-context chains, interfaces, orchestration.', nodes: ['mrklAgentChat_0'], edges: [], ascii: `[mrklAgentChat_0]` }
    ];

    function renderHolonicAtlas() {
      const el = holonListDiv;
      el.innerHTML = '';
      holonDefs.forEach(h => {
        const wrap = document.createElement('div');
        wrap.style.border = '1px solid #333a52';
        wrap.style.borderRadius = '8px';
        wrap.style.padding = '8px';
        wrap.style.marginBottom = '8px';
        wrap.innerHTML = `
          <div class="holon" style="color:${h.color}">${h.name}</div>
          <div style="margin:6px 0">${h.description}</div>
          <div style="margin:6px 0"><strong>Nodes:</strong> ${
            h.nodes.map(n => `<span class="atlas-node" data-node="${normalizeId(n)}">${normalizeId(n)}</span>`).join(', ')
          }</div>
          <pre>${h.ascii}</pre>
        `;
        el.appendChild(wrap);
      });
      // click-to-focus nodes from atlas
      el.querySelectorAll('.atlas-node').forEach(a => {
        a.addEventListener('click', () => {
          const id = a.getAttribute('data-node');
          if (nodes.get(id)) {
            network.focus(id, { scale: 1.2, animation: { duration: 600, easingFunction: 'easeInOutQuart' } });
            network.selectNodes([id]);
          }
        });
      });
    }

    // ---------- Legend & Filters ----------
    const legend = document.getElementById('legend');
    Object.entries(groups).forEach(([g, c]) => {
      const row = document.createElement('div'); row.className = 'flex';
      row.innerHTML = `<input type="checkbox" id="chk-${g}" checked style="margin-right:6px">
                       <span class="dot" style="background:${c}"></span>${g}`;
      legend.appendChild(row);
      row.querySelector('input').addEventListener('change', e => {
        const isChecked = e.target.checked;
        const groupNodes = nodes.get({ filter: n => n.group === g });
        const updates = groupNodes.map(node => ({ id: node.id, hidden: !isChecked }));
        nodes.update(updates);
      });
    });

    document.getElementById('search').addEventListener('input', e => {
      const q = e.target.value.toLowerCase();
      const allNodes = nodes.get({ fields: ['id', 'label', 'group'] });
      const updates = allNodes.map(n => {
        const isGroupVisible = document.getElementById(`chk-${n.group}`).checked;
        const matchesSearch = n.label.toLowerCase().includes(q);
        return { id: n.id, hidden: !(isGroupVisible && matchesSearch) };
      });
      nodes.update(updates);
    });

    // ---------- Info Box (node + edge) ----------
    const infoBox = document.getElementById('infoBox');
    const infoTitle = document.getElementById('infoTitle');
    const infoBody = document.getElementById('infoBody');
    document.getElementById('infoClose').onclick = () => { infoBox.style.display = 'none'; };

    network.on('click', params => {
      if (params.nodes.length) {
        const id = params.nodes[0];
        infoTitle.textContent = id;
        infoBody.innerHTML = nodeLineages[id] || '— Lineage data not yet transcribed for this node. —';
        infoBox.style.display = 'block';
      } else if (params.edges.length) {
        const eid = params.edges[0];
        const e = edges.get(eid);
        infoTitle.textContent = `${e.from} → ${e.to}`;
        const rel = e.relation ? `<p><strong>Relation:</strong> ${e.relation}</p>` : '';
        const why = e.why ? `<p><strong>Why:</strong> ${e.why}</p>` : '';
        infoBody.innerHTML = `${rel}${why || '<p>—</p>'}`;
        infoBox.style.display = 'block';
      } else {
        infoBox.style.display = 'none';
      }
    });

    // ---------- Controls ----------
    document.getElementById('resetBtn').onclick = () => network.fit();
    document.getElementById('exportJsonBtn').onclick = () => {
      const exportData = { rawData, unifiedEdgeList, nodeLineages };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'unified-spiral-glyphode.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };
    document.getElementById('exportImgBtn').onclick = () => {
      const cvs = document.querySelector('#network canvas');
      if (cvs) cvs.toBlob(b => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(b);
        a.download = 'spiral-glyphode.png';
        a.click();
        URL.revokeObjectURL(a.href);
      });
    };

    let clustered = false;
    const clusterBtn = document.getElementById('clusterBtn');
    clusterBtn.onclick = () => {
      clusterBtn.disabled = true;
      if (!clustered) {
        Object.keys(groups).forEach(g => {
          const clusterOptions = {
            joinCondition: n => n.group === g,
            clusterNodeProperties: { id: `cluster-${g}`, label: `${g} cluster`, shape: 'database', color: groups[g] }
          };
          network.cluster(clusterOptions);
        });
        clustered = true;
        clusterBtn.textContent = 'Uncluster All';
      } else {
        Object.keys(groups).forEach(g => {
          if (network.isCluster && network.isCluster(`cluster-${g}`)) {
            network.openCluster(`cluster-${g}`);
          }
        });
        clustered = false;
        clusterBtn.textContent = 'Toggle Clusters';
      }
      setTimeout(() => { clusterBtn.disabled = false; }, 1000);
    };
  }
</script>
</body>
</html>

